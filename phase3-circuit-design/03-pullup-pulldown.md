# 03. 풀업/풀다운 저항 (Pull-up / Pull-down Resistors)

## 목차
1. [플로팅(Floating) 상태란?](#1-플로팅floating-상태란)
2. [풀업 저항 (Pull-up Resistor)](#2-풀업-저항-pull-up-resistor)
3. [풀다운 저항 (Pull-down Resistor)](#3-풀다운-저항-pull-down-resistor)
4. [풀업 vs 풀다운 비교](#4-풀업-vs-풀다운-비교)
5. [ESP32 내부 풀업/풀다운](#5-esp32-내부-풀업풀다운)
6. [I2C에서 외부 풀업 저항이 필요한 이유](#6-i2c에서-외부-풀업-저항이-필요한-이유)
7. [저항값 선택 가이드](#7-저항값-선택-가이드)
8. [핵심 정리](#8-핵심-정리)

---

## 1. 플로팅(Floating) 상태란?

### 정의

**플로팅(Floating)** 상태란, 디지털 입력 핀이 **VCC에도 GND에도 연결되지 않은 상태**를 말합니다. 이 상태에서 핀의 전압은 정해지지 않아서(undefined), HIGH와 LOW 사이에서 **불규칙하게 변동**합니다.

### 소프트웨어 비유

> 플로팅은 프로그래밍에서 **초기화되지 않은 변수**와 같습니다.
>
> ```cpp
> int value;              // 초기화 안 함 → 값이 뭔지 모름 (쓰레기 값)
> if (value == 1) { ... } // 결과를 예측할 수 없음!
> ```
>
> 마찬가지로, 플로팅 상태의 핀을 읽으면:
> ```cpp
> pinMode(pin, INPUT);              // 아무것도 연결 안 됨 → 플로팅!
> int state = digitalRead(pin);     // 0일 수도 1일 수도 있음
> ```

### 플로팅 상태의 문제

```
  플로팅 상태의 핀 전압 (시간에 따른 변화):

  3.3V ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   HIGH 판정 기준
         ╱╲    ╱╲        ╱╲
        ╱  ╲  ╱  ╲  ╱╲  ╱  ╲     ╱╲
  1.6V ╱────╲╱────╲╱──╲╱────╲───╱──╲───   ← 전압이 불안정하게 변동
       ╱                          ╲
  0V ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   LOW 판정 기준

  → MCU가 읽으면 어떤 때는 HIGH, 어떤 때는 LOW
  → 버튼을 안 눌러도 눌린 것처럼 동작할 수 있음
  → 주변 전자기 노이즈에 의해 값이 변함
```

### 왜 플로팅이 발생하나?

```
  잘못된 버튼 연결 (풀업/풀다운 없음):

                    ESP32
                  ┌────────┐
                  │        │
        [SW1]─────┤ GPIO4  │
         │        │        │
        GND       └────────┘

  버튼을 눌렀을 때:  GPIO4 = LOW (GND에 연결됨) ✓ 확실
  버튼을 안 눌렀을 때: GPIO4 = ??? (아무 데도 안 연결됨!) ✗ 플로팅!

  → 버튼을 안 눌렀을 때 GPIO4의 상태를 정의할 수 없음
  → 이 문제를 해결하는 것이 풀업/풀다운 저항
```

---

## 2. 풀업 저항 (Pull-up Resistor)

### 개념

풀업 저항은 입력 핀을 **저항을 통해 VCC(전원)에 연결**하여, 기본 상태를 **HIGH**로 만드는 저항입니다.

### 동작 원리

```
  풀업 저항 회로:

        VCC (3.3V)
         │
        [R1]  ← 풀업 저항 (10kΩ)
        10kΩ
         │
         ●────── GPIO4 (ESP32 입력)
         │
        [SW1]  ← 푸시 버튼 (Normally Open)
         │
        GND
```

**버튼을 누르지 않았을 때 (기본 상태):**

```
        VCC (3.3V)
         │
        [R1]          전류 경로: VCC → R1 → GPIO4
        10kΩ          GPIO4에는 거의 전류가 흐르지 않음
         │            (입력 핀의 임피던스가 매우 높음)
         ●──→ GPIO4 = HIGH (3.3V)  ✓ 확정!
         │
        [SW1] 열림 (OFF)
         │
        GND (연결 안 됨)

  → 전류가 흐를 곳이 없으므로 R1에 전압 강하 없음
  → GPIO4 ≈ VCC = 3.3V = HIGH
```

**버튼을 눌렀을 때:**

```
        VCC (3.3V)
         │
        [R1]          전류 경로: VCC → R1 → GND (스위치 통해)
        10kΩ          R1에 전체 전압이 걸림
         │
         ●──→ GPIO4 = LOW (≈0V)  ✓ 확정!
         │
        [SW1] 닫힘 (ON)
         │
        GND (직접 연결)

  → 스위치를 통해 GPIO4가 GND에 직접 연결
  → GND(0V)의 "힘"이 저항(R1)을 통한 VCC보다 강함
  → GPIO4 ≈ GND = 0V = LOW
```

### 풀업의 핵심 이해

```
  왜 버튼을 누르면 LOW가 될까?

  VCC(3.3V) ─── R1(10kΩ) ──●── GPIO4
                             │
                          SW1(닫힘)
                             │
                           GND(0V)

  GPIO4에서 보면:
  - VCC 쪽: 10kΩ 저항을 통해 3.3V에 연결 (약한 연결)
  - GND 쪽: 스위치를 통해 직접 0V에 연결 (강한 연결)

  직접 연결(≈0Ω)이 저항(10kΩ)을 통한 연결보다 "강하므로"
  GPIO4는 GND 쪽(0V, LOW)으로 끌려감

  소프트웨어 비유:
  - R1 = "약한" 기본값 설정 (default parameter)
  - SW1 = "강한" 명시적 값 전달 (explicit argument)
  - 명시적 값이 있으면 기본값을 무시하는 것과 같음
```

### 풀업 저항의 전류 계산

```
  버튼을 눌렀을 때 R1에 흐르는 전류:

  I = V / R = 3.3V / 10kΩ = 0.33mA

  → 매우 작은 전류 (LED 하나 못 켤 정도)
  → 전력 소비도 무시할 수 있는 수준
  → P = V × I = 3.3V × 0.33mA ≈ 1.1mW
```

---

## 3. 풀다운 저항 (Pull-down Resistor)

### 개념

풀다운 저항은 입력 핀을 **저항을 통해 GND에 연결**하여, 기본 상태를 **LOW**로 만드는 저항입니다.

### 동작 원리

```
  풀다운 저항 회로:

        VCC (3.3V)
         │
        [SW1]  ← 푸시 버튼
         │
         ●────── GPIO4 (ESP32 입력)
         │
        [R1]  ← 풀다운 저항 (10kΩ)
        10kΩ
         │
        GND
```

**버튼을 누르지 않았을 때 (기본 상태):**

```
        VCC (3.3V)
         │
        [SW1] 열림 (OFF)  ← 연결 안 됨
         │
         ●──→ GPIO4 = LOW (≈0V)  ✓ 확정!
         │
        [R1]   전류 경로 없음 (스위치 열려있으므로)
        10kΩ   R1이 핀을 GND로 "당김(pull-down)"
         │
        GND

  → R1을 통해 GPIO4가 GND에 연결
  → 전류가 흐르지 않으므로 R1에 전압 강하 없음
  → GPIO4 ≈ GND = 0V = LOW
```

**버튼을 눌렀을 때:**

```
        VCC (3.3V)
         │
        [SW1] 닫힘 (ON)  ← VCC에 직접 연결
         │
         ●──→ GPIO4 = HIGH (≈3.3V)  ✓ 확정!
         │
        [R1]   전류 경로: VCC → SW1 → R1 → GND
        10kΩ   하지만 GPIO4는 VCC 쪽으로 끌려감
         │
        GND

  → SW1을 통해 GPIO4가 VCC에 직접 연결
  → VCC(3.3V)의 직접 연결이 R1(10kΩ)을 통한 GND보다 강함
  → GPIO4 ≈ VCC = 3.3V = HIGH
```

---

## 4. 풀업 vs 풀다운 비교

### 동작 비교표

| 항목 | 풀업 저항 | 풀다운 저항 |
|------|----------|------------|
| 저항 연결 위치 | VCC와 핀 사이 | 핀과 GND 사이 |
| 기본 상태 (버튼 안 누름) | **HIGH** | **LOW** |
| 버튼 누름 시 | **LOW** | **HIGH** |
| 버튼의 다른 쪽 연결 | GND | VCC |
| 코드에서 읽기 | `LOW`이면 눌림 | `HIGH`이면 눌림 |
| 사용 빈도 | 더 많이 사용 | 덜 사용 |

### 회로 비교 (나란히)

```
  [풀업 저항]                    [풀다운 저항]

      VCC                            VCC
       │                              │
      [R]  ← 풀업                   [SW]  ← 스위치
       │                              │
       ●── GPIO                       ●── GPIO
       │                              │
      [SW]  ← 스위치                 [R]  ← 풀다운
       │                              │
      GND                            GND

  기본: HIGH                     기본: LOW
  누름: LOW                      누름: HIGH
```

### 왜 풀업이 더 많이 사용되나?

1. **역사적 이유**: TTL IC 시대부터 풀업이 표준이었음
2. **내부 풀업 지원**: 대부분의 MCU가 내부 풀업 저항을 제공 (풀다운은 지원 안 하는 경우도 있음)
3. **버튼 배선 용이**: 버튼의 한쪽을 GND에 연결하는 것이 더 간단
4. **I2C 등 프로토콜**: 오픈 드레인 방식에서 풀업이 필수

### 소프트웨어 비유: 초기값 설정

```cpp
// 풀업 = 기본값 true, 버튼 누르면 false
bool buttonState = true;     // 풀업: 초기값 HIGH(true)
if (buttonPressed) {
    buttonState = false;     // 눌리면 LOW(false)로 변경
}

// 풀다운 = 기본값 false, 버튼 누르면 true
bool buttonState = false;    // 풀다운: 초기값 LOW(false)
if (buttonPressed) {
    buttonState = true;      // 눌리면 HIGH(true)로 변경
}

// 플로팅 = 초기값 없음!
bool buttonState;            // 초기화 안 함 → undefined!
// 읽으면 true일 수도 false일 수도 → 버그!
```

---

## 5. ESP32 내부 풀업/풀다운

### ESP32의 장점

ESP32는 대부분의 GPIO 핀에 **내부 풀업/풀다운 저항**이 내장되어 있습니다. 소프트웨어로 활성화할 수 있어서 외부 저항 없이도 버튼을 사용할 수 있습니다.

### 사용 방법

```cpp
// 내부 풀업 사용 (외부 저항 필요 없음!)
pinMode(GPIO_NUM_4, INPUT_PULLUP);

// 내부 풀다운 사용 (ESP32는 풀다운도 지원!)
pinMode(GPIO_NUM_4, INPUT_PULLDOWN);

// 외부 저항 사용 (내부 풀업/풀다운 사용 안 함)
pinMode(GPIO_NUM_4, INPUT);
```

### 내부 풀업 사용 시 회로

```
  외부 풀업 저항 사용:              내부 풀업 사용:

      VCC                          (내부에 이미 있음)
       │                              ┌──────────┐
      [R]  10kΩ (외부 부품)           │ ESP32    │
       │                              │          │
       ●── GPIO4                      │ GPIO4 ●──│── (내부 풀업)
       │                              │          │
      [SW]                            └──────────┘
       │                                   │
      GND                                [SW]
                                           │
                                          GND

  부품 수: 저항 + 스위치 = 2개       부품 수: 스위치 = 1개만!
```

### 내부 풀업 코드 예제

```cpp
const int BUTTON_PIN = 4;
const int LED_PIN = 2;

void setup() {
    // 내부 풀업 활성화 → 외부 저항 필요 없음!
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);
    Serial.begin(115200);
}

void loop() {
    int buttonState = digitalRead(BUTTON_PIN);

    // 풀업이므로: 안 누름 = HIGH, 누름 = LOW
    if (buttonState == LOW) {
        Serial.println("버튼 눌림!");
        digitalWrite(LED_PIN, HIGH);
    } else {
        digitalWrite(LED_PIN, LOW);
    }
    delay(50);  // 디바운싱용 짧은 딜레이
}
```

### 내부 vs 외부 풀업 비교

| 항목 | 내부 풀업 | 외부 풀업 |
|------|----------|----------|
| 저항값 | 약 45kΩ (ESP32) | 원하는 값 선택 가능 |
| 추가 부품 | 불필요 | 저항 1개 필요 |
| 전류 능력 | 약함 (약 73uA) | 저항값에 따라 조절 가능 |
| 노이즈 내성 | 보통 | 낮은 저항값으로 강하게 가능 |
| I2C용 | 부족함 | 4.7kΩ 권장 |
| 용도 | 단순 버튼 입력 | 정밀한 제어, 통신 라인 |

### 주의: 사용할 수 없는 핀

ESP32의 일부 핀은 내부 풀업/풀다운이 지원되지 않거나, 부팅 시 특수 기능이 있어 주의가 필요합니다.

| 핀 | 주의사항 |
|----|---------|
| GPIO34, 35, 36, 39 | 입력 전용 핀, 내부 풀업/풀다운 없음 → 외부 저항 필수 |
| GPIO0 | 부팅 모드 선택 핀, 풀업 필요 (보통 보드에 내장) |
| GPIO2 | 부팅 시 LOW여야 함 (일부 보드) |
| GPIO12 | 플래시 전압 설정 핀 (일부 보드에서 주의) |
| GPIO15 | 부팅 로그 출력 제어 |

---

## 6. I2C에서 외부 풀업 저항이 필요한 이유

### I2C 통신이란? (간략 소개)

I2C는 2개의 선(SDA: 데이터, SCL: 클럭)으로 여러 장치를 연결하는 통신 방식입니다.

### 오픈 드레인 (Open-Drain) 출력

I2C는 **오픈 드레인** 방식을 사용합니다. 이는 장치가 선을 **LOW로 당길 수는 있지만, HIGH로 밀어올릴 수는 없는** 구조입니다.

```
  오픈 드레인 동작:

  장치가 통신할 때:
  - "0"을 보낼 때: 선을 GND로 당김 (능동적) → LOW
  - "1"을 보낼 때: 선을 놓아줌 (아무것도 안 함) → ???

  풀업 저항이 없으면:
  - "1"을 보낼 때 선이 플로팅 → 불안정!

  풀업 저항이 있으면:
  - "1"을 보낼 때 풀업 저항이 VCC로 당겨줌 → HIGH!
```

### I2C 풀업 저항 회로

```
        VCC (3.3V)          VCC (3.3V)
         │                   │
        [Rp]                [Rp]
        4.7kΩ               4.7kΩ
         │                   │
  SDA ───●───────────────────│──── SDA
         │                   │
         │          SCL ─────●──── SCL
         │                   │
    ┌────┴────┐         ┌────┴────┐
    │  ESP32  │         │  센서   │
    │ (마스터) │         │ (슬레이브)│
    │ GPIO21  │         │  SDA    │
    │ GPIO22  │         │  SCL    │
    └─────────┘         └─────────┘

  Rp = 풀업 저항 (보통 4.7kΩ)

  왜 4.7kΩ인가?
  - 너무 작으면 (예: 1kΩ): 전류가 많이 흐름, 전력 소비 증가
  - 너무 크면 (예: 100kΩ): 신호가 HIGH로 올라가는 속도가 느림
  - 4.7kΩ은 속도와 전력의 균형점
  - 짧은 배선(30cm 이내): 4.7kΩ ~ 10kΩ
  - 긴 배선 또는 고속: 2.2kΩ ~ 4.7kΩ
```

### 왜 내부 풀업으로는 부족한가?

```
  ESP32 내부 풀업: 약 45kΩ

  45kΩ으로 I2C를 사용하면:
  - 신호가 HIGH로 올라가는 시간이 너무 느림
  - I2C 클럭 속도(100kHz, 400kHz)를 따라가지 못함
  - 통신 오류 발생 가능

  외부 4.7kΩ 풀업:
  - 약 10배 더 강한 풀업 → 빠르게 HIGH로 복귀
  - 안정적인 I2C 통신 보장

  비유: 내부 풀업(45kΩ) = 느린 인터넷 (다운로드 가능하지만 느림)
       외부 풀업(4.7kΩ) = 빠른 인터넷 (원활한 통신)
```

### I2C 모듈에 이미 풀업이 있는 경우

많은 I2C 센서 모듈(예: BME280, OLED 모듈)은 보드에 이미 풀업 저항이 포함되어 있습니다.

```
  모듈에 풀업 내장된 경우:

  ┌──── I2C 센서 모듈 ─────┐
  │  VCC ──[4.7kΩ]── SDA   │   ← 모듈 안에 이미 있음
  │  VCC ──[4.7kΩ]── SCL   │   ← 모듈 안에 이미 있음
  │                        │
  │  SDA  SCL  VCC  GND    │   ← 외부 핀
  └──┬────┬────┬────┬──────┘
     │    │    │    │
   ESP32               → 외부에 추가 풀업 불필요!
```

> **팁:** I2C가 동작하지 않을 때, 가장 먼저 풀업 저항을 확인하세요.
> 모듈에 내장되어 있지 않다면 외부에 4.7kΩ을 추가해야 합니다.

---

## 7. 저항값 선택 가이드

### 일반적인 풀업/풀다운 저항값

| 용도 | 권장 저항값 | 이유 |
|------|-----------|------|
| 일반 버튼 입력 | 10kΩ | 전류 소비와 노이즈 내성의 균형 |
| I2C 풀업 | 4.7kΩ | 통신 속도 요구사항 충족 |
| 노이즈가 심한 환경 | 1kΩ ~ 4.7kΩ | 강한 풀업으로 노이즈에 강함 |
| 저전력 설계 | 47kΩ ~ 100kΩ | 전류 소비 최소화 |
| ESP32 내부 풀업 | ~45kΩ (고정) | 간단한 버튼에 적합 |

### 저항값에 따른 전류 소비

```
  VCC = 3.3V에서 버튼을 눌렀을 때 흐르는 전류:

  저항값     전류          전력
  1kΩ       3.3mA        10.9mW    ← 노이즈에 강하지만 전류 소비 큼
  4.7kΩ     0.7mA        2.3mW     ← I2C용 적합
  10kΩ      0.33mA       1.1mW     ← 일반 버튼용 (가장 일반적)
  47kΩ      0.07mA       0.23mW    ← 저전력용
  100kΩ     0.033mA      0.11mW    ← 매우 저전력, 노이즈에 약함
```

### 저항값이 너무 크면?

```
  100kΩ 풀업의 문제:

  VCC (3.3V)
   │
  [R] 100kΩ  ← 매우 약한 풀업
   │
   ●── GPIO4
   │
  [SW]
   │
  GND

  문제:
  - 풀업 "힘"이 약해서 주변 노이즈에 영향받음
  - 손가락을 가까이 대면 전압이 변할 수 있음 (인체의 정전기)
  - 긴 배선에서는 더 심각

  → 일반적으로 10kΩ이 안전한 선택
```

---

## 실습: 풀업 vs 풀다운 비교 실험

### 준비물

- ESP32
- 택트 스위치 2개
- 10kΩ 저항 2개
- 브레드보드, 점퍼선

### 회로

```
  [풀업 회로 - GPIO4]              [풀다운 회로 - GPIO5]

      3.3V                             3.3V
       │                                │
      [R1]                             [SW2]
      10kΩ                              │
       │                                ●── GPIO5
       ●── GPIO4                        │
       │                               [R2]
      [SW1]                            10kΩ
       │                                │
      GND                              GND
```

### 코드

```cpp
const int PULLUP_BTN = 4;     // 풀업 저항 연결된 버튼
const int PULLDOWN_BTN = 5;   // 풀다운 저항 연결된 버튼

void setup() {
    Serial.begin(115200);
    pinMode(PULLUP_BTN, INPUT);     // 외부 풀업이 있으므로 그냥 INPUT
    pinMode(PULLDOWN_BTN, INPUT);   // 외부 풀다운이 있으므로 그냥 INPUT
}

void loop() {
    int pullupState = digitalRead(PULLUP_BTN);
    int pulldownState = digitalRead(PULLDOWN_BTN);

    Serial.print("풀업 버튼 (GPIO4): ");
    Serial.print(pullupState);
    Serial.print(" → ");
    Serial.print(pullupState == LOW ? "눌림" : "안 눌림");

    Serial.print("  |  풀다운 버튼 (GPIO5): ");
    Serial.print(pulldownState);
    Serial.print(" → ");
    Serial.println(pulldownState == HIGH ? "눌림" : "안 눌림");

    delay(200);
}

/*
  시리얼 출력 예시:

  풀업 버튼 (GPIO4): 1 → 안 눌림  |  풀다운 버튼 (GPIO5): 0 → 안 눌림
  풀업 버튼 (GPIO4): 1 → 안 눌림  |  풀다운 버튼 (GPIO5): 0 → 안 눌림
  풀업 버튼 (GPIO4): 0 → 눌림     |  풀다운 버튼 (GPIO5): 0 → 안 눌림  ← 풀업 버튼만 누름
  풀업 버튼 (GPIO4): 1 → 안 눌림  |  풀다운 버튼 (GPIO5): 1 → 눌림     ← 풀다운 버튼만 누름
*/
```

---

## 8. 핵심 정리

```
┌──────────────────────────────────────────────────────────┐
│                풀업/풀다운 저항 핵심 정리                    │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  1. 플로팅 = 초기화 안 된 변수 → 값 예측 불가               │
│     해결책: 풀업 또는 풀다운 저항으로 기본값 설정            │
│                                                          │
│  2. 풀업 저항: VCC → R → 핀 → SW → GND                    │
│     기본 HIGH, 누르면 LOW                                  │
│                                                          │
│  3. 풀다운 저항: VCC → SW → 핀 → R → GND                  │
│     기본 LOW, 누르면 HIGH                                  │
│                                                          │
│  4. 일반 버튼: 10kΩ 권장                                  │
│     I2C 풀업: 4.7kΩ 권장                                  │
│                                                          │
│  5. ESP32 내부 풀업/풀다운:                                │
│     INPUT_PULLUP / INPUT_PULLDOWN으로 활성화               │
│     단순 버튼에 적합, I2C에는 부족                          │
│                                                          │
│  6. GPIO34~39: 입력 전용, 내부 풀업 없음 → 외부 저항 필수   │
│                                                          │
│  7. I2C 외부 풀업이 필요한 이유:                            │
│     오픈 드레인 방식 → HIGH로 밀어줄 저항 필요              │
│     내부 45kΩ으로는 통신 속도 부족 → 4.7kΩ 사용            │
│                                                          │
│  소프트웨어 비유:                                         │
│  풀업/풀다운 = 변수 초기값 설정                             │
│  플로팅 = undefined / 초기화 안 된 변수                    │
│  int x = 0;  ← 풀다운 (기본 LOW)                         │
│  int x = 1;  ← 풀업 (기본 HIGH)                          │
│  int x;      ← 플로팅 (기본값 없음!) ← 위험!              │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

**다음 장:** [04. 전압 분배기](./04-voltage-divider.md)에서 전압 분배기 공식과 5V→3.3V 레벨 변환 방법을 학습합니다.
